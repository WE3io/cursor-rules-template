<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Use Static Types | AI Blindspots</title>
<meta name=title content="Use Static Types"><meta name=description content="The eternal debate between dynamic and static type systems concerns the
tradeoff between ease of prototyping and long term maintainability.  The rise
of LLMs greatly reduces the pressure to choose a language that is good at
prototyping, since the LLM can cover up for boilerplate and refactors.  Choose
accordingly.  You will want an agent setup where the LLM is informed about
type errors after changes they make, so they can easily tell what other files
they need to update when doing refactors.  Be careful about your token costs."><meta name=keywords content><meta property="og:url" content="https://ezyang.github.io/ai-blindspots/use-static-types/"><meta property="og:site_name" content="AI Blindspots"><meta property="og:title" content="Use Static Types"><meta property="og:description" content="The eternal debate between dynamic and static type systems concerns the tradeoff between ease of prototyping and long term maintainability. The rise of LLMs greatly reduces the pressure to choose a language that is good at prototyping, since the LLM can cover up for boilerplate and refactors. Choose accordingly. You will want an agent setup where the LLM is informed about type errors after changes they make, so they can easily tell what other files they need to update when doing refactors. Be careful about your token costs."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-03-06T10:42:57-05:00"><meta property="article:modified_time" content="2025-03-06T10:42:57-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Use Static Types"><meta name=twitter:description content="The eternal debate between dynamic and static type systems concerns the tradeoff between ease of prototyping and long term maintainability. The rise of LLMs greatly reduces the pressure to choose a language that is good at prototyping, since the LLM can cover up for boilerplate and refactors. Choose accordingly. You will want an agent setup where the LLM is informed about type errors after changes they make, so they can easily tell what other files they need to update when doing refactors. Be careful about your token costs."><meta itemprop=name content="Use Static Types"><meta itemprop=description content="The eternal debate between dynamic and static type systems concerns the tradeoff between ease of prototyping and long term maintainability. The rise of LLMs greatly reduces the pressure to choose a language that is good at prototyping, since the LLM can cover up for boilerplate and refactors. Choose accordingly. You will want an agent setup where the LLM is informed about type errors after changes they make, so they can easily tell what other files they need to update when doing refactors. Be careful about your token costs."><meta itemprop=datePublished content="2025-03-06T10:42:57-05:00"><meta itemprop=dateModified content="2025-03-06T10:42:57-05:00"><meta itemprop=wordCount content="156"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:800px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--code-background-color:#f2f2f2;--code-color:#222;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#333;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--code-background-color:#777;--code-color:#ddd;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px}blockquote{border-left:1px solid #999;color:var(--code-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{padding:1px 15px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ai-blindspots/ class=title><h2>AI Blindspots</h2></a><nav><a href=/ai-blindspots/>Home</a>
<a href=/ai-blindspots/blog>Blog</a></nav></header><main><h1>Use Static Types</h1><p><i><time datetime=2025-03-06>2025-03-06</time></i></p><content><p>The eternal debate between dynamic and static type systems concerns the
tradeoff between ease of prototyping and long term maintainability. The rise
of LLMs greatly reduces the pressure to choose a language that is good at
prototyping, since the LLM can cover up for boilerplate and refactors. Choose
accordingly. You will want an agent setup where the LLM is informed about
type errors after changes they make, so they can easily tell what other files
they need to update when doing refactors. Be careful about your token costs.</p><p>Unfortunately, the training corpus highly emphasizes Python and JavaScript.
Their typed offerings are workable, but as both are gradual type systems you
will need to carefully setup the typechecker settings to be strict (or
carefully prompt your LLM to setup the settings properly).</p><p>In principle, Rust should be a good target language for LLMs. However, LLMs
are not as good at generating Rust as they are for Python/JavaScript.</p></content><p></p></main><footer></footer></body></html>